{"ast":null,"code":"var _jsxFileName = \"/Users/kiahakala/Documents/awesome-cats/frontend/src/pages/Cats.js\",\n  _s = $RefreshSig$();\nimport { useLoaderData, json, defer } from 'react-router-dom';\nimport CatsList from '../components/CatsList';\n\n// With react router data can be fetched beforehand\n// No need to render the component first and then fetch data <- suboptimal!\n// Browser supported response creation can be used to reduce code\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction CatsPage() {\n  _s();\n  const data = useLoaderData(); // part of the response\n  const cats = data.cats; // extracted from the data object\n\n  return /*#__PURE__*/_jsxDEV(CatsList, {\n    cats: cats\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 13,\n    columnNumber: 3\n  }, this);\n}\n_s(CatsPage, \"5thj+e1edPyRpKif1JmVRC6KArE=\", false, function () {\n  return [useLoaderData];\n});\n_c = CatsPage;\nexport default CatsPage;\nasync function loadCats() {\n  const response = await fetch('http://localhost:8080/cats');\n  if (!response.ok) {\n    throw json({\n      message: 'Could not fetch cats :('\n    }, {\n      status: 500\n    });\n  } else {\n    return response;\n  }\n}\n\n// Defer function enables rendering component even if the future data is not there yet\nexport async function loader() {\n  defer({\n    cats: loadCats()\n  });\n}\n\n// import { useState, useEffect } from 'react'\n\n// const [isLoading, setIsLoading] = useState(false)\n// const [fetchedCats, setFetchedCats] = useState()\n// const [error, setError] = useState()\n\n// useEffect(() => {\n// \tasync function fetchCats() {\n// \t\tsetIsLoading(true)\n// \t\tconst response = await fetch('http://localhost:8080/cats')\n\n// \t\tif (!response.ok) {\n// \t\t\tsetError('Fetching cats failed')\n// \t\t} else {\n// \t\t\tconst resData = await response.json()\n// \t\t\tsetFetchedCats(resData.cats)\n// \t\t}\n// \t\tsetIsLoading(false)\n// \t}\n// \tfetchCats()\n// }, [])\n\n// return (\n// \t<>\n// \t\t<div style={{ textAlign: 'center '}}>\n// \t\t\t{isLoading && <p>Loading...</p>}\n// \t\t\t{error && <p>{error}</p>}\n// \t\t</div>\n// \t\t{!isLoading && fetchedCats && <CatsList cats={fetchedCats} />}\n// \t</>\n\n// )\nvar _c;\n$RefreshReg$(_c, \"CatsPage\");","map":{"version":3,"names":["useLoaderData","json","defer","CatsList","CatsPage","data","cats","loadCats","response","fetch","ok","message","status","loader"],"sources":["/Users/kiahakala/Documents/awesome-cats/frontend/src/pages/Cats.js"],"sourcesContent":["import { useLoaderData, json, defer } from 'react-router-dom'\nimport CatsList from '../components/CatsList'\n\n// With react router data can be fetched beforehand\n// No need to render the component first and then fetch data <- suboptimal!\n// Browser supported response creation can be used to reduce code\n\nfunction CatsPage() {\n\tconst data = useLoaderData() // part of the response\n\tconst cats = data.cats // extracted from the data object\n\n\treturn (\n\t\t<CatsList cats={cats} />\n\t)\n}\n\nexport default CatsPage\n\nasync function loadCats() {\n\tconst response = await fetch('http://localhost:8080/cats')\n\n\tif (!response.ok) {\n\t\tthrow json(\n\t\t\t{ message: 'Could not fetch cats :(' }, { status: 500 }\n\t\t\t)\n\t} else {\n\t\treturn response\n\t}\n}\n\n// Defer function enables rendering component even if the future data is not there yet\nexport async function loader() {\n\tdefer({\n\t\tcats: loadCats()\n\t})\n}\n\n// import { useState, useEffect } from 'react'\n\n// const [isLoading, setIsLoading] = useState(false)\n\t// const [fetchedCats, setFetchedCats] = useState()\n\t// const [error, setError] = useState()\n\n\t// useEffect(() => {\n\t// \tasync function fetchCats() {\n\t// \t\tsetIsLoading(true)\n\t// \t\tconst response = await fetch('http://localhost:8080/cats')\n\n\t// \t\tif (!response.ok) {\n\t// \t\t\tsetError('Fetching cats failed')\n\t// \t\t} else {\n\t// \t\t\tconst resData = await response.json()\n\t// \t\t\tsetFetchedCats(resData.cats)\n\t// \t\t}\n\t// \t\tsetIsLoading(false)\n\t// \t}\n\t// \tfetchCats()\n\t// }, [])\n\n// return (\n// \t<>\n// \t\t<div style={{ textAlign: 'center '}}>\n// \t\t\t{isLoading && <p>Loading...</p>}\n// \t\t\t{error && <p>{error}</p>}\n// \t\t</div>\n// \t\t{!isLoading && fetchedCats && <CatsList cats={fetchedCats} />}\n// \t</>\n\t\n// )"],"mappings":";;AAAA,SAASA,aAAa,EAAEC,IAAI,EAAEC,KAAK,QAAQ,kBAAkB;AAC7D,OAAOC,QAAQ,MAAM,wBAAwB;;AAE7C;AACA;AACA;AAAA;AAEA,SAASC,QAAQ,GAAG;EAAA;EACnB,MAAMC,IAAI,GAAGL,aAAa,EAAE,EAAC;EAC7B,MAAMM,IAAI,GAAGD,IAAI,CAACC,IAAI,EAAC;;EAEvB,oBACC,QAAC,QAAQ;IAAC,IAAI,EAAEA;EAAK;IAAA;IAAA;IAAA;EAAA,QAAG;AAE1B;AAAC,GAPQF,QAAQ;EAAA,QACHJ,aAAa;AAAA;AAAA,KADlBI,QAAQ;AASjB,eAAeA,QAAQ;AAEvB,eAAeG,QAAQ,GAAG;EACzB,MAAMC,QAAQ,GAAG,MAAMC,KAAK,CAAC,4BAA4B,CAAC;EAE1D,IAAI,CAACD,QAAQ,CAACE,EAAE,EAAE;IACjB,MAAMT,IAAI,CACT;MAAEU,OAAO,EAAE;IAA0B,CAAC,EAAE;MAAEC,MAAM,EAAE;IAAI,CAAC,CACtD;EACH,CAAC,MAAM;IACN,OAAOJ,QAAQ;EAChB;AACD;;AAEA;AACA,OAAO,eAAeK,MAAM,GAAG;EAC9BX,KAAK,CAAC;IACLI,IAAI,EAAEC,QAAQ;EACf,CAAC,CAAC;AACH;;AAEA;;AAEA;AACC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}